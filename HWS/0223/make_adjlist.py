'''
4 4
1 2 2 3 2 4 3 4

'''

V, E = map(int, input().split()) #V는 노드의 범위의 갯수 1에서7까지, E는 간선의 갯수
arr = list(map(int, input().split()))
adj = [[0]*(V+1) for _ in range(V+1)] #인접한 노드를 기록 #노드는 1번부터 시작이지만, 인덱스는 0번부터 시작이니까 V+1개 생성
print(adj)
adjList = [[] for _ in range(V+1)] #1번과 인접한 노드, 2번과 인접한 노드들을 각각 기록해줄 비어있는 V+1개만큼의 2차원 배열, 인덱스는 0번부터 시작이니까
print(adjList)
for i in range(E):
    n1, n2 = arr[i*2], arr[i*2+1] #n1의 인덱스는 0,2,4,6 / n2의 인덱스는 1,3,5,7
    adj[n1][n2] = 1     # n1과 n2는 인접
    adj[n2][n1] = 1     # 방향 표시가 없는 경우 #왕복이 가능한 경우

    adjList[n1].append(n2) #인접 인덱스 n1의 자리 즉 1과 이어진 길에 n2에 저장된 2를 등록하고
    adjList[n2].append(n1) #인저버 인덱스 n2의 자리 즉 2와 이어진 길에 n1에 저장된 1을 등록 이걸 모두 순회해주면

print(adj) # [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 1], [0, 0, 1, 0, 1], [0, 0, 1, 1, 0]] #이어져있는지 여부를 나타낸 2차원배열
print(adjList) # [[], [2], [1, 3, 4], [2, 4], [2, 3]] #인덱스를 활용한 간선정보 1과 이어진 2 / 2와 이어진 1,3,4 / 3과 이어진 2,4 / 4와 이어진 2,3
